<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Posts - 我的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">

	<link rel="stylesheet" href="/css/style.css">
		<link rel="alternate" type="application/rss+xml" href="/post/index.xml" title="我的博客">

	<link rel="shortcut icon" href="http://dewey363.github.io/favicon.ico">

	
		
</head>
<body class="body">
	<header class="header">
	
	<div class="logo">
		<div class="container">
			<a class="logo__link" href="/" title="我的博客" rel="home">
				<div class="logo__item logo__text">
						<div class="logo__title">我的博客</div>
						
					</div>
			</a>
		</div>
	</div>

</header>
<div class="divider"></div>


	<div class="container wrapper flex">
		<div class="primary">
		
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E7%BB%93%E6%9E%84%E4%BD%93/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 结构体 Go语言结构体数据类是将各个类型的变量定义的集合，通常用来表示记录。
package main import &#34;fmt&#34; // 这个person结构体有name和age成员 type person struct { name string age int } func main() { // 这个语法创建一个新结构体变量 	fmt.Println(person{&#34;Bob&#34;, 20}) // 可以使用&#34;成员:值&#34;的方式来初始化结构体变量 	fmt.Println(person{name: &#34;Alice&#34;, age: 30}) // 未显式赋值的成员初始值为零值 	fmt.Println(person{name: &#34;Fred&#34;}) // 可以使用&amp;来获取结构体变量的地址 	fmt.Println(&amp;person{name: &#34;Ann&#34;, age: 40}) // 使用点号(.)来访问结构体成员 	s := person{name: &#34;Sean&#34;, age: 50} fmt.Println(s.name) // 结构体指针也可以使用点号(.)来访问结构体成员 	// Go语言会自动识别出来 	sp := &amp;s fmt.Println(sp.age) // 结构体成员变量的值是可以改变的 	sp.age = 51 fmt.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4go%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%BB%BA%E8%AE%AE/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 语言实战: 编写可维护 Go 语言代码建议 目录   1. 指导原则
 1.1 简单性 1.2 可读性 1.3 生产力    2. 标识符
 2.1 选择标识是为了清晰, 而不是简洁 2.2 标识符长度 2.3 不要用变量类型命名变量 2.4 使用一致的命名风格 2.5 使用一致的声明样式 2.6 成为团队的合作者    3. 注释
 3.1 关于变量和常量的注释应描述其内容而非其目的 3.2 公共符号始终要注释    4. 包的设计
 4.1 一个好的包从它的名字开始 4.2 避免使用类似 base 、common 或 util 的包名称 4.3 尽早 return 而不是深度嵌套 4.4 让零值更有用 4.5 避免包级别状态    5.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 自定义排序 有的时候我们希望排序不是仅仅按照自然顺序排序。例如，我们希望按照字符串的长度来对一个字符串数组排序而不是按照字母顺序来排序。这里我们介绍一下Go的自定义排序。
package main import &#34;sort&#34; import &#34;fmt&#34; // 为了能够使用自定义函数来排序，我们需要一个 // 对应的排序类型，比如这里我们为内置的字符串 // 数组定义了一个别名ByLength type ByLength []string // 我们实现了sort接口的Len，Less和Swap方法 // 这样我们就可以使用sort包的通用方法Sort // Len和Swap方法的实现在不同的类型之间大致 // 都是相同的，只有Less方法包含了自定义的排序 // 逻辑，这里我们希望以字符串长度升序排序 func (s ByLength) Len() int { return len(s) } func (s ByLength) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s ByLength) Less(i, j int) bool { return len(s[i]) &lt; len(s[j]) } // 一切就绪之后，我们就可以把需要进行自定义排序 // 的字符串类型fruits转换为ByLength类型，然后使用 // sort包的Sort方法来排序 func main() { fruits := []string{&#34;peach&#34;, &#34;banana&#34;, &#34;kiwi&#34;} sort.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADnull%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决数据库中null值的问题 https://blog.csdn.net/qq_15437667/article/details/78780945
要点 从数据库读取可能为null值得值时，可以选择使用sql.NULL来读取；或者使用IFNULL、COALESCE等命令让数据库查询值返回不为”“或者NULL 若需要往数据库中插入null值，则依然可以使用sql.NULL存储所需的值，然后进行插入NULL值 直接使用sql.NULL***类型容易出现valid遗漏设置等问题，普通int、string与其转换时，请写几个简单的get、set函数 本demo使用的数据库表以及数据如下
mysql&gt; desc person; +&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;+&mdash;&ndash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;-+ | Field | Type | Null | Key | Default | Extra | +&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;+&mdash;&ndash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;-+ | id | int(11) | NO | PRI | NULL | auto_increment | | first_name | varchar(100) | NO | | NULL | | | last_name | varchar(40) | YES | | NULL | | | age | int(11) | YES | | NULL | | +&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;+&mdash;&ndash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;-+
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%AE%A1%E6%97%B6%E5%99%A8/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 计时器 我们有的时候希望Go在未来的某个时刻执行或者是以一定的时间间隔重复执行。Go内置的timer和ticker功能使得这些任务变得简单了。我们先看看timer的功能，下一节再看看ticker的功能。
package main import &#34;time&#34; import &#34;fmt&#34; func main() { // Timer 代表了未来的一个事件，你告诉timer需要等待多久，然后 	// 计时器提供了一个通道，这个通道将在等待的时间结束后得到通知， 	// 这里的timer将等待2秒 	timer1 := time.NewTimer(time.Second * 2) // 这里`&lt;-timer1.C`在timer的通道`C`上面阻塞等待，直到有个值发送给该 	// 通道，通知通道计时器已经等待完成。 	// timer.NewTimer方法获取的timer1的结构体定义为 	// type Ticket struct{ 	// C &lt;-chan Time 	//} 	&lt;-timer1.C fmt.Println(&#34;Timer 1 expired&#34;) // 如果你仅仅需要等待的话，你可以使用`time.Sleep`，而timer的 	// 独特之处在于你可以在timer等待完成之前取消等待。 	timer2 := time.NewTimer(time.Second) go func() { &lt;-timer2.C fmt.Println(&#34;Timer 2 expired&#34;) }() stop2 := timer2.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 请求处理频率控制 频率控制是控制资源利用和保证服务高质量的重要机制。Go可以使用goroutine，channel和ticker来以优雅的方式支持频率控制。
package main import &#34;time&#34; import &#34;fmt&#34; func main() { // 首先我们看下基本的频率限制。假设我们得控制请求频率， 	// 我们使用一个通道来处理所有的这些请求，这里向requests 	// 发送5个数据，然后关闭requests通道 	requests := make(chan int, 5) for i := 1; i &lt;= 5; i++ { requests &lt;- i } close(requests) // 这个limiter的Ticker每隔200毫秒结束通道阻塞 	// 这个limiter就是我们频率控制处理器 	limiter := time.Tick(time.Millisecond * 200) // 通过阻塞从limiter通道接受数据，我们将请求处理控制在每隔200毫秒 	// 处理一个请求，注意`&lt;-limiter`的阻塞作用。 	for req := range requests { &lt;-limiter fmt.Println(&#34;request&#34;, req, time.Now()) } // 我们可以保持正常的请求频率限制，但也允许请求短时间内爆发 	// 我们可以通过通道缓存来实现，比如下面的这个burstyLimiter 	// 就允许同时处理3个事件。 	burstyLimiter := make(chan time.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 读取文件 读写文件是很多程序的基本任务，下面我们看看Go里面的文件读取。
package main import ( &#34;bufio&#34; &#34;fmt&#34; &#34;io&#34; &#34;io/ioutil&#34; &#34;os&#34; ) // 读取文件的函数调用大多数都需要检查错误， // 使用下面这个错误检查方法可以方便一点 func check(e error) { if e != nil { panic(e) } } func main() { // 最基本的文件读写任务就是把整个文件的内容读取到内存 	dat, err := ioutil.ReadFile(&#34;/tmp/dat&#34;) check(err) fmt.Print(string(dat)) // 有的时候你想更多地控制到底是读取文件的哪个部分，这个 	// 时候你可以使用`os.Open`打开一个文件获取一个`os.File` 	// 对象 	f, err := os.Open(&#34;/tmp/dat&#34;) // 从这个文件中读取一些字节，并且由于字节数组长度所限， 	// 最多读取5个字节，另外还需要注意实际能够读取的字节 	// 数量 	b1 := make([]byte, 5) n1, err := f.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%B6%85%E6%97%B6/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 超时 超时对那些连接外部资源的程序来说是很重要的，否则就需要限定执行时间。在Go里面实现超时很简单。我们可以使用channel和select很容易地做到。
package main import &#34;time&#34; import &#34;fmt&#34; func main() { // 在这个例子中，假设我们执行了一个外部调用，2秒之后将结果写入c1 	c1 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c1 &lt;- &#34;result 1&#34; }() // 这里使用select来实现超时，`res := &lt;-c1`等待通道结果， 	// `&lt;- Time.After`则在等待1秒后返回一个值，因为select首先 	// 执行那些不再阻塞的case，所以这里会执行超时程序，如果 	// `res := &lt;-c1`超过1秒没有执行的话 	select { case res := &lt;-c1: fmt.Println(res) case &lt;-time.After(time.Second * 1): fmt.Println(&#34;timeout 1&#34;) } // 如果我们将超时时间设为3秒，这个时候`res := &lt;-c2`将在 	// 超时case之前执行，从而能够输出写入通道c2的值 	c2 := make(chan string, 1) go func() { time.
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 进程执行 在上面的例子中，我们演示了一下如何去触发执行一个外部的进程。我们这样做的原因是我们希望从Go进程里面可以访问外部进程的信息。但有的时候，我们仅仅希望执行一个外部进程来替代当前的Go进程。这个时候，我们需要使用Go提供的exec函数。
package main import &#34;syscall&#34; import &#34;os&#34; import &#34;os/exec&#34; func main() { // 本例中，我们使用`ls`来演示。Go需要一个该命令 	// 的完整路径，所以我们使用`exec.LookPath`函数来 	// 找到它 	binary, lookErr := exec.LookPath(&#34;ls&#34;) if lookErr != nil { panic(lookErr) } // `Exec`函数需要一个切片参数，我们给ls命令一些 	// 常见的参数。注意，第一个参数必须是程序名称 	args := []string{&#34;ls&#34;, &#34;-a&#34;, &#34;-l&#34;, &#34;-h&#34;} // `Exec`还需要一些环境变量，这里我们提供当前的 	// 系统环境 	env := os.Environ() // 这里是`os.Exec`调用。如果一切顺利，我们的原 	// 进程将终止，然后启动一个新的ls进程。如果有 	// 错误发生，我们将获得一个返回值 	execErr := syscall.Exec(binary, args, env) if execErr !
	</div>
</article>
<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/go-%E8%BF%9B%E7%A8%8B%E8%A7%A6%E5%8F%91/" rel="bookmark">
			
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 进程触发 有的时候，我们需要从Go程序里面触发一个其他的非Go进程来执行。
package main import &#34;fmt&#34; import &#34;io/ioutil&#34; import &#34;os/exec&#34; func main() { // 我们从一个简单的命令开始，这个命令不需要任何参数 	// 或者输入，仅仅向stdout输出一些信息。`exec.Command` 	// 函数创建了一个代表外部进程的对象 	dateCmd := exec.Command(&#34;date&#34;) // `Output`是另一个运行命令时用来处理信息的函数，这个 	// 函数等待命令结束，然后收集命令输出。如果没有错误发 	// 生的话，`dateOut`将保存date的信息 	dateOut, err := dateCmd.Output() if err != nil { panic(err) } fmt.Println(&#34;&gt; date&#34;) fmt.Println(string(dateOut)) // 下面我们看一个需要从stdin输入数据的命令，我们将 	// 数据输入传给外部进程的stdin，然后从它输出到stdout 	// 的运行结果收集信息 	grepCmd := exec.Command(&#34;grep&#34;, &#34;hello&#34;) // 这里我们显式地获取input/output管道，启动进程， 	// 向进程写入数据，然后读取输出结果，最后等待进程结束 	grepIn, _ := grepCmd.
	</div>
</article>

</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/post/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/8</span>
	<a class="pagination__item pagination__item--next btn" href="/post/page/7/">»</a>
</div>

		</div>
		

	</div>
	<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 我的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/pfadfinder-konstanz/hugo-dpsg/" rel="nofollow noopener" target="_blank">DPSG</a> theme.</span>
			
		</div>
		

	</div>
</footer>

	<script async defer src="/js/menu.js"></script>
	
	
	
</body>
</html>
